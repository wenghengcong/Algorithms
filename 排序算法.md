### 冒泡排序







# 选择排序

**每一趟找出未排序中最小的元素，放到已排序的最后。**

基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。

基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。



第1趟，在待排序记录r[1]-r[n]中选出最小的记录，将它与r[1]交换；

第2趟，在待排序记录r[2]-r[n]中选出最小的记录，将它与r[2]交换；

以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。

![选择排序](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-13-114535.jpg)



```c++
void selectionSort(int arr[], int n){

    for(int i = 0 ; i < n ; i ++){	//n-1趟排序
        // 寻找[i, n)区间里的最小值
        int minIndex = i;	//假设minIndex处对应的数组元素是最小的
        for( int j = i + 1 ; j < n ; j ++ ) //查找最小记录的位置
            if( arr[j] < arr[minIndex] )
                minIndex = j;

        swap( arr[i] , arr[minIndex] );
    }
}
```



# 插入排序

https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F

每一趟找出元素的插入位置。

插入排序类似整理扑克牌，将每一张牌插到其他已经有序的牌中适当的位置。

![image-20190113200434452](http://blog-1251606168.file.myqcloud.com/blog_2018/2019-01-13-120434.png)

```c++
void insertionSort(T arr[], int n){

    for( int i = 1 ; i < n ; i ++ ) {

        // 寻找元素arr[i]合适的插入位置
        // 写法1
//        for( int j = i ; j > 0 ; j-- )
//            if( arr[j] < arr[j-1] )
//                swap( arr[j] , arr[j-1] );
//            else
//                break;

        // 写法2
//        for( int j = i ; j > 0 && arr[j] < arr[j-1] ; j -- )
//            swap( arr[j] , arr[j-1] );

        // 写法3
        T e = arr[i];
        int j; // j保存元素e应该插入的位置
        for (j = i; j > 0 && arr[j-1] > e; j--)
            arr[j] = arr[j-1];
        arr[j] = e;
    }

    return;
}
```



